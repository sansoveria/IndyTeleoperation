///////////////////////////////////////////////////////////////////////////////
// Module1.cpp
#include "TcPch.h"
#pragma hdrstop

#include "Module1.h"
#include "Module1Ads.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif
DEFINE_THIS_FILE()

///////////////////////////////////////////////////////////////////////////////
// CModule1
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Collection of interfaces implemented by module CModule1
BEGIN_INTERFACE_MAP(CModule1)
	INTERFACE_ENTRY_ITCOMOBJECT()
	INTERFACE_ENTRY(IID_ITcADI, ITcADI)
	INTERFACE_ENTRY(IID_ITcWatchSource, ITcWatchSource)
///<AutoGeneratedContent id="InterfaceMap">
	INTERFACE_ENTRY(IID_ITcCyclic, ITcCyclic)
///</AutoGeneratedContent>
END_INTERFACE_MAP()


IMPLEMENT_ITCOMOBJECT(CModule1)
IMPLEMENT_ITCOMOBJECT_SETSTATE_LOCKOP2(CModule1)
IMPLEMENT_ITCADI(CModule1)
IMPLEMENT_ITCWATCHSOURCE(CModule1)

///////////////////////////////////////////////////////////////////////////////
// Set parameters of CModule1 
BEGIN_SETOBJPARA_MAP(CModule1)
	SETOBJPARA_DATAAREA_MAP()
///<AutoGeneratedContent id="SetObjectParameterMap">
	SETOBJPARA_VALUE(PID_TcTraceLevel, m_TraceLevelMax)
	SETOBJPARA_VALUE(PID_Module1DefaultAdsPort, m_DefaultAdsPort)
	SETOBJPARA_VALUE(PID_Ctx_AdsPort, m_ContextAdsPort)
	SETOBJPARA_VALUE(PID_Module1Counter, m_Counter)
	SETOBJPARA_ITFPTR(PID_Ctx_TaskOid, m_spCyclicCaller)
///</AutoGeneratedContent>
END_SETOBJPARA_MAP()

///////////////////////////////////////////////////////////////////////////////
// Get parameters of CModule1 
BEGIN_GETOBJPARA_MAP(CModule1)
	GETOBJPARA_DATAAREA_MAP()
///<AutoGeneratedContent id="GetObjectParameterMap">
	GETOBJPARA_VALUE(PID_TcTraceLevel, m_TraceLevelMax)
	GETOBJPARA_VALUE(PID_Module1DefaultAdsPort, m_DefaultAdsPort)
	GETOBJPARA_VALUE(PID_Ctx_AdsPort, m_ContextAdsPort)
	GETOBJPARA_VALUE(PID_Module1Counter, m_Counter)
	GETOBJPARA_ITFPTR(PID_Ctx_TaskOid, m_spCyclicCaller)
///</AutoGeneratedContent>
	GETOBJPARA_TYPE_CODE(PID_Module1AdsPort, WORD, *p = AmsGetPort())
END_GETOBJPARA_MAP()

///////////////////////////////////////////////////////////////////////////////
// Get watch entries of CModule1
BEGIN_OBJPARAWATCH_MAP(CModule1)
	OBJPARAWATCH_DATAAREA_MAP()
///<AutoGeneratedContent id="ObjectParameterWatchMap">
	OBJPARAWATCH_VALUE(PID_Module1Counter, m_Counter)
///</AutoGeneratedContent>
END_OBJPARAWATCH_MAP()

///////////////////////////////////////////////////////////////////////////////
// Get data area members of CModule1
BEGIN_OBJDATAAREA_MAP(CModule1)
///<AutoGeneratedContent id="ObjectDataAreaMap">
	OBJDATAAREA_VALUE(ADI_Module1Inputs, m_Inputs)
	OBJDATAAREA_VALUE(ADI_Module1Outputs, m_Outputs)
	OBJDATAAREA_VALUE(ADI_Module1DeviceStates, m_DeviceStates)
	OBJDATAAREA_VALUE(ADI_Module1UserInputs, m_UserInputs)
///</AutoGeneratedContent>
END_OBJDATAAREA_MAP()


///////////////////////////////////////////////////////////////////////////////
CModule1::CModule1()
	: m_Trace(m_TraceLevelMax, m_spSrv)
{
///<AutoGeneratedContent id="MemberInitialization">
	m_TraceLevelMax = tlAlways;
	m_DefaultAdsPort = 0;
	m_ContextAdsPort = 0;
	m_Counter = 0;
	memset(&m_Inputs, 0, sizeof(m_Inputs));
	memset(&m_Outputs, 0, sizeof(m_Outputs));
	memset(&m_DeviceStates, 0, sizeof(m_DeviceStates));
	memset(&m_UserInputs, 0, sizeof(m_UserInputs));
///</AutoGeneratedContent>
}

///////////////////////////////////////////////////////////////////////////////
CModule1::~CModule1() 
{
}

///////////////////////////////////////////////////////////////////////////////
// State Transitions 
///////////////////////////////////////////////////////////////////////////////
IMPLEMENT_ITCOMOBJECT_SETOBJSTATE_IP_PI(CModule1)

///////////////////////////////////////////////////////////////////////////////
// State transition from PREOP to SAFEOP
//
// Initialize input parameters 
// Allocate memory
HRESULT CModule1::SetObjStatePS(PTComInitDataHdr pInitData)
{
	m_Trace.Log(tlVerbose, FENTERA);
	HRESULT hr = S_OK;
	IMPLEMENT_ITCOMOBJECT_EVALUATE_INITDATA(pInitData);

	hr = SUCCEEDED(hr) ? InitAmsPort(m_spSrv, m_DefaultAdsPort) : hr;

	// cleanup on failure
	if (FAILED(hr))
	{
		ShutdownAmsPort();
	}
	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from SAFEOP to OP
//
// Register with other TwinCAT objects
HRESULT CModule1::SetObjStateSO()
{
	m_Trace.Log(tlVerbose, FENTERA);
	HRESULT hr = S_OK;

	// TODO: Add any additional initialization


	// If following call is successful the CycleUpdate method will be called, 
	// possibly even before this method has been left.
	hr = FAILED(hr) ? hr : AddModuleToCaller(); 

	// Cleanup if transition failed at some stage
	if ( FAILED(hr) )
	{
		RemoveModuleFromCaller(); 
	}
	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from OP to SAFEOP
HRESULT CModule1::SetObjStateOS()
{
	m_Trace.Log(tlVerbose, FENTERA);

	HRESULT hr = S_OK;

	RemoveModuleFromCaller(); 

	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from SAFEOP to PREOP
HRESULT CModule1::SetObjStateSP()
{
	m_Trace.Log(tlVerbose, FENTERA);

	HRESULT hr = S_OK;
	ShutdownAmsPort();

	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///<AutoGeneratedContent id="ImplementationOf_ITcCyclic">
HRESULT CModule1::CycleUpdate(ITcTask* ipTask, ITcUnknown* ipCaller, ULONG_PTR context)
{
	HRESULT hr = S_OK;

	// handle pending ADS indications and confirmations
	CheckOrders();

	// TODO: Additional evaluation of input from ADS indication or confirmations

	// TODO: Submit your ADS requests 
	ULONGLONG cnt = 0;
	if (SUCCEEDED(ipTask->GetCycleCounter(&cnt)))
	{
		// calculate FK and Jacobian
		double r11, r12, r13, r21, r22, r23, r31, r32, r33;
		double j11, j12, j21, j22, j31, j32;
		double theta1, theta2;
		double c1, s1, c2, s2, a, ca, sa;
		double angle, axis1, axis2, axis3;
		theta1 = -double(m_Inputs.Position1 - m_DeviceStates.AngleZero1) * 2.0 * TC_M_PI / 4096.0 / GEAR_RATIO_1;
		theta2 = -double(m_Inputs.Position2 - m_DeviceStates.AngleZero2) * 2.0 * TC_M_PI / 4096.0 / GEAR_RATIO_2;
		m_DeviceStates.Angle1 = LONG(theta1 / TC_M_PI * 180.0 * 1000.0);		// degree
		m_DeviceStates.Angle2 = LONG(theta2 / TC_M_PI * 180.0 * 1000.0);		// degree
		c1 = cos_(theta1);
		s1 = sin_(theta1);
		c2 = cos_(theta2);
		s2 = sin_(theta2);
		a = sqrt_(c1 * c1 * c2 * c2 + s2 * s2);
		ca = c1 * c2 / a;
		sa = -s2 / a;

		r11 = ca * c1;
		r12 = -sa * c1;
		r13 = -s1;
		r21 = sa;
		r22 = ca;
		r23 = 0.0;
		r31 = ca * s1;
		r32 = -sa * s1;
		r33 = c1;

		angle = acos_((r11 + r22 + r33 - 1) / 2.0);
		axis1 = (r32 - r23) / sqrt_((r32 - r23) * (r32 - r23) + (r13 - r31) * (r13 - r31) + (r21 - r12) * (r21 - r12));
		axis2 = (r13 - r31) / sqrt_((r32 - r23) * (r32 - r23) + (r13 - r31) * (r13 - r31) + (r21 - r12) * (r21 - r12));
		axis3 = (r21 - r12) / sqrt_((r32 - r23) * (r32 - r23) + (r13 - r31) * (r13 - r31) + (r21 - r12) * (r21 - r12));
		m_DeviceStates.U = angle * axis1 * 1000;
		m_DeviceStates.V = angle * axis2 * 1000;
		m_DeviceStates.W = angle * axis3 * 1000;

		j11 = -s2 / a;
		j12 = 0.0;
		j21 = -c1 * c2 / a;
		j22 = 0.0;
		j31 = s1 * c2 * s2 / a / a;
		j32 = c1 / a / a;

		if (m_UserInputs.EnableMotor1) m_Outputs.Controlword1 = 0x0F;
		else m_Outputs.Controlword1 = 0x06;
		if (m_UserInputs.EnableMotor2) m_Outputs.Controlword2 = 0x0F;
		else m_Outputs.Controlword2 = 0x06;

		if (m_DeviceStates.CalibrationFlag != m_UserInputs.CalibrationFlag) {
			m_DeviceStates.AngleZero1 = m_Inputs.Position1;
			m_DeviceStates.AngleZero2 = m_Inputs.Position2;
			m_DeviceStates.CalibrationFlag = m_UserInputs.CalibrationFlag;
		}

		if (m_Outputs.Controlword1 == 0x0F && m_Outputs.Controlword2 == 0x0F) {
			
			float tau1In, tau2In, tau3In, tau1, tau2, tau3, tauLeverComp, torque1, torque2;
			
			tau1In = float(m_UserInputs.Tau1) / 1000.0;
			tau2In = float(m_UserInputs.Tau2) / 1000.0;
			tau3In = float(m_UserInputs.Tau3) / 1000.0;

			// remove lever-direction torque (x axis in local coordinate)
			tauLeverComp = r11 * tau1In + r21 * tau2In + r31 * tau3In;
			tau1 = tau1In - tauLeverComp * r11;
			tau2 = tau2In - tauLeverComp * r21;
			tau3 = tau3In - tauLeverComp * r31;
						
			torque1 = tau1 * j11 + tau2 * j21 + tau3 * j31;
			torque2 = tau1 * j12 + tau2 * j22 + tau3 * j32;

			
			LONG targetTorque1, targetTorque2;
			//targetTorque1 = LONG(tau2In / NOMINAL_TORQUE * 1000.0);
			//targetTorque2 = LONG(tau3In / NOMINAL_TORQUE * 1000.0);
			//m_DeviceStates.Angle1 = LONG(torque1 / NOMINAL_TORQUE * 1000.0);
			//m_DeviceStates.Angle2 = LONG(torque2 / NOMINAL_TORQUE * 1000.0);
			targetTorque1 = LONG(torque1 / NOMINAL_TORQUE * 1000.0);
			targetTorque2 = LONG(-torque2 / NOMINAL_TORQUE * 1000.0);
			if (targetTorque1 > 100) targetTorque1 = 100;
			if (targetTorque1 < -100) targetTorque1 = -100;
			if (targetTorque2 > 100) targetTorque2 = 100;
			if (targetTorque2 < -100) targetTorque2 = -100;

			m_Outputs.TargetTorque1 = targetTorque1;
			m_Outputs.TargetTorque2 = targetTorque2;

			if (m_Inputs.Statusword1 == 4663) m_DeviceStates.MotorState1 = true;
			else m_DeviceStates.MotorState1 = false;
			if (m_Inputs.Statusword2 == 4663) m_DeviceStates.MotorState2 = true;
			else m_DeviceStates.MotorState2 = false;
		}
		else {
			m_DeviceStates.MotorState1 = false;
			m_DeviceStates.MotorState2 = false;
		}

		/*if (cnt%100 == 0)
		{
			SubmitAdsReadReq();
		}*/
	}

	return hr;
}
///</AutoGeneratedContent>

///////////////////////////////////////////////////////////////////////////////
HRESULT CModule1::AddModuleToCaller()
{
	m_Trace.Log(tlVerbose, FENTERA);

	HRESULT hr = S_OK;
	if ( m_spCyclicCaller.HasOID() )
	{
		if ( SUCCEEDED_DBG(hr = m_spSrv->TcQuerySmartObjectInterface(m_spCyclicCaller)) )
		{
			if ( FAILED(hr = m_spCyclicCaller->AddModule(m_spCyclicCaller, THIS_CAST(ITcCyclic))) )
			{
				m_spCyclicCaller = NULL;
			}
		}
	}
	else
	{
		hr = ADS_E_INVALIDOBJID; 
		SUCCEEDED_DBGT(hr, "Invalid OID specified for caller task");
	}
	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
VOID CModule1::RemoveModuleFromCaller()
{
	m_Trace.Log(tlVerbose, FENTERA);

	if ( m_spCyclicCaller )
	{
		m_spCyclicCaller->RemoveModule(m_spCyclicCaller);
	}
	m_spCyclicCaller	= NULL;
	m_Trace.Log(tlVerbose, FLEAVEA);
}

///////////////////////////////////////////////////////////////////////////////
void CModule1::AdsReadWriteInd
(
	AmsAddr& rAddr, 
	ULONG invokeId, 
	ULONG indexGroup,
	ULONG indexOffset, 
	ULONG cbReadLength, 
	ULONG cbWriteLength, 
	PVOID pData 
)
{
	m_Trace.Log(tlVerbose, FENTERA "oid=0x%08x, invokeId=%d, indexGroup=0x%08x, indexOffset=0x%08x, cbReadLength=%d, cbWriteLength=%d, pData=0x%p",
		m_objId.value, invokeId, indexGroup, indexOffset, cbReadLength, cbWriteLength, pData);

	switch(indexGroup)
	{
	case Module1IndexGroup1:
		switch(indexOffset)
		{

		case Module1IndexOffset1:
			m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x", 
				m_objId.value, indexGroup, indexOffset );

			// TODO: add custom code here

			AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 0, NULL); 
			break;

		case Module1IndexOffset2:
			m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x", 
				m_objId.value, indexGroup, indexOffset );

			// TODO: add custom code here

			AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 0, NULL); 
			break;
		}
		break;
	case Module1IndexGroup2:
		switch(indexOffset)
		{

		case Module1IndexOffset1:
			m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x", 
				m_objId.value, indexGroup, indexOffset );

			// TODO: add custom code here

			AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 0, NULL); 
			break;

		case Module1IndexOffset2:
			m_Trace.Log(tlInfo, FNAMEA "oid=0x%08x indexGroup=0x%08x, indexOffset=0x%08x", 
				m_objId.value, indexGroup, indexOffset );

			// TODO: add custom code here

			AdsReadWriteRes(rAddr, invokeId, ADSERR_NOERR, 0, NULL); 
			break;
		}
		break;
	default:
		__super::AdsReadWriteInd(rAddr, invokeId, indexGroup, indexOffset, cbReadLength, cbWriteLength, pData); 
		break;
	}
	m_Trace.Log(tlVerbose, FLEAVEA);
}


void CModule1::SubmitAdsReadReq()
{
	m_Trace.Log(tlVerbose, FENTERA);
	// m_ContextAdsPort contains the ADS port number of the task associated with context 1
	// amsAddr refers to the ADS port of this task 
	AmsAddr amsAddr(this->AmsGetNetId(), m_ContextAdsPort);

	// Request the value of a parameter from a TwinCAT module instance
	// via the task ADS port.
	// The object id of the instance is passed as index group and
	// the parameter id is passed as index offset.
	// The result is delivered by a call to AdsReadCon and can 
	// be identified by the invoke id. 
	int nRes = 
		AdsReadReq
		(
			amsAddr, 
			invokeIdReadByOidAndPid, 
			m_objId.value, 
			PID_Module1Counter,
			sizeof(m_ReadByOidAndPid)
		);
	if (nRes != ADSERR_NOERR)
	{
		m_Trace.Log(tlError, FNAMEA "AdsReadReq failed with error=0x%08x(%s)", nRes, AdsGetErrorText(nRes));
	}
	else
	{
		m_Trace.Log(tlInfo, FNAMEA "AdsReadReq by oid=0x%08x and pid=0x%08x", m_objId.value, PID_Module1AdsPort);
	}
	m_Trace.Log(tlVerbose, FLEAVEA);
}

///////////////////////////////////////////////////////////////////////////////
void CModule1::AdsReadCon
(
	AmsAddr& rAddr,
	ULONG invokeId,
	ULONG nResult,
	ULONG cbLength,
	PVOID pData
)
{
	m_Trace.Log(tlVerbose, FENTERA "oid=0x%08x, invokeId=%d, nResult=0x%08x, cbLength=%d, pData=0x%p",
		m_objId.value, invokeId, nResult, cbLength, pData);

	if (invokeId == invokeIdReadByOidAndPid)
	{
		if (nResult != ADSERR_NOERR)
		{
			m_Trace.Log(tlWarning, FNAMEA "ReadByOidAndPid failed with error=0x%x(%s)",
				nResult, AdsGetErrorText(nResult));
		}
		else if (cbLength == sizeof(m_ReadByOidAndPid))
		{
			m_ReadByOidAndPid = *static_cast<PULONG>(pData); 
			m_Trace.Log(tlInfo, FNAMEA "m_ReadByOidAndPid=0x%x", m_ReadByOidAndPid);
		}
	}
	else
	{
		__super::AdsReadWriteCon( rAddr, invokeId, nResult, cbLength, pData );
	}
	m_Trace.Log(tlVerbose, FLEAVEA);
}

